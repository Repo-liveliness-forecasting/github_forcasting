---
title: "Forecasting issues"
author: "Forecast Padawan 2"
date: "November 17, 2016"
output: pdf_document
---

The goal of this experiment is to design the best model to forcaste the number of issue in the per day in the comming two weeks. We think that this could help Open Source organisation to manage there human ressources.

# Load the data

```{r results='hide', message=FALSE, warning=FALSE}
#install.packages('forecast')

library('forecast')
library(knitr)
#load the data frame
issues.csv <- read.csv("issues/julialang_julia.csv")
commits.csv <- read.csv("commits/julialang_julia.csv")

issues.csv$date = as.POSIXlt(as.Date(issues.csv$date,format='%m/%d/%Y'))
commits.csv$date = as.POSIXlt(as.Date(commits.csv$date,format='%m/%d/%Y'))
```

keep the last 12 months

```{r}
to_date <- issues.csv$date[length(issues.csv$date)]
from_date <- to_date
from_date$year <- from_date$year - 1

issues.csv <- subset(issues.csv, date <= to_date & date >= from_date)
commits.csv <- subset(commits.csv, date <= to_date & date >= from_date)
```

```{r}
#loading issues and commits into a ts object
issues.ts <- ts(issues.csv$number_of_issues, frequency = 7) 

Acf(issues.ts, lag.max = 14, main = "")

commits.ts <- ts(commits.csv$number_of_commits, frequency = 7) 
plot(issues.ts, main = 'Issues', bty = 'l', ylab = 'Number of Issues')
plot(commits.ts, main = 'Commits', bty = 'l', ylab = 'Number of Commits')
```

```{r}
time <- time(issues.ts)

n.sample <- 14
n.valid <- 21


separate.train.test <- function(timeserie, n.valid) {
  time <- time(timeserie)
  n.train <- length(timeserie) - n.valid
  results = list()
  results$train.ts <- window(timeserie, start=time[1], end=time[n.train])
  results$valid.ts <- window(timeserie, start=time[n.train+1], end=time[n.train+n.valid])
  return(results)
}

all.issues <- sapply(0:(n.sample - 1), function(i) return(separate.train.test(window(issues.ts,start=time[1],end=time[length(issues.ts)-i]), n.valid)))

issues  <- separate.train.test(issues.ts, n.valid)
commits  <- separate.train.test(commits.ts, n.valid)
```

```{r}
mean.all.accuracy <- function(all.forecast) {
  Reduce("+", all.forecast['summary',])/length(all.forecast['summary',])
}

plot.all.residuals <- function(all.forecast) {
  plot(1, type="l", xlab="", ylab="", main="Residuals", xlim=c(48.5, 53.3), ylim=c(-30, 30))
  sapply(1:n.sample, function(i) lines(all.forecast['residual',i]$residual))
  return(NULL)
}

plot.all.pred <- function(all.forecast) {
  plot(issues.ts, main="Prediction",xlim=c(30, 53.3))
  if (class(all.forecast['pred',1]$pred) == "forecast") {
    sapply(1:n.sample, function(i) lines(all.forecast['pred',i]$pred$mean, col=rgb(0, 0, 1, 0.5)))
  } else {
    sapply(1:n.sample, function(i) lines(all.forecast['pred',i]$pred, col=rgb(0, 0, 1, 0.5)))
  }
  return(NULL)
}

hist.all.residuals <- function(all.forecast) {
  residuals <- sapply(1:n.sample, function(i) as.numeric(all.forecast['residual',i]$residual))
  boxplot(residuals)
  hist(residuals)
  quantile(residuals,c(0.975,0.95,0.05,0.025))
}
```

# Naive Forecast

## Naive

```{r kable}

naive.forecast <- function(sample) {
  results = list()
  results$valid <- sample$valid.ts
  results$pred <- naive(sample$train.ts, h=n.valid)
  results$residual <- sample$valid.ts - results$pred$mean
  results$summary <- accuracy(results$pred, sample$valid.ts)
  
  return(results)
}

all.naive.forecast <- sapply(1:n.sample, function(i) return(naive.forecast(all.issues[,i])))

kable(mean.all.accuracy(all.naive.forecast))
plot.all.pred(all.naive.forecast)
plot.all.residuals(all.naive.forecast)
hist.all.residuals(all.naive.forecast)

```


## Seasonal Naive

```{r} 
snaive.forecast <- function(sample) {
  results = list()
  results$valid <- sample$valid.ts
  results$pred <- snaive(sample$train.ts, h=n.valid)
  results$residual <- sample$valid.ts - results$pred$mean
  results$summary <- accuracy(results$pred, sample$valid.ts)
  
  return(results)
}

all.snaive.forecast <- sapply(1:n.sample, function(i) return(snaive.forecast(all.issues[,i])))

kable(mean.all.accuracy(all.snaive.forecast))
plot.all.pred(all.snaive.forecast)
plot.all.residuals(all.snaive.forecast)
hist.all.residuals(all.snaive.forecast)
```

# Smoothing

## Holt Winter

```{r}
hw.forecast <- function(sample) {
  results = list()
  results$valid <- sample$valid.ts
  results$model <- ets(sample$train.ts, model = "ZAA")
  results$pred <- forecast(results$model, h=n.valid)
  results$residual <- sample$valid.ts - results$pred$mean
  results$summary <- accuracy(results$pred, sample$valid.ts)
  
  return(results)
}

all.hw.forecast <- sapply(1:n.sample, function(i) return(hw.forecast(all.issues[,i])))

kable(mean.all.accuracy(all.hw.forecast))
plot.all.pred(all.hw.forecast)
plot.all.residuals(all.hw.forecast)
hist.all.residuals(all.hw.forecast)
```

## Double differencing

```{r}
ma.dd.forecast <- function(sample) {
  train.issues.d1 <- diff(sample$train.ts, lag = 1)
  train.issues.d1.d7 <- diff(train.issues.d1, lag = 7)
  
  ma.trailing <- rollmean(train.issues.d1.d7, k = 7, align = "right")
  last.ma <- tail(ma.trailing, 1)
  ma.trailing.pred <- ts(c(ma.trailing, rep(last.ma, n.valid)), start=c(3, 1), frequency = 7)
  
  ma.dd.pred.d1 <- train.issues.d1
  ma.dd.pred <- sample$train.ts
  
  for(i in 1:(n.valid/7)) {
    ma.dd.pred.d1 <- ma.trailing.pred + lag(ma.dd.pred.d1,k = -7)
    ma.dd.pred <- ma.dd.pred.d1 + lag(ma.dd.pred,k = -8)
  }
  
  results = list()
  results$valid <- sample$valid.ts
  
  results$pred <- ma.dd.pred
  results$residual <- sample$valid.ts - results$pred
  results$summary <- accuracy(results$pred, sample$valid.ts)
  
  return(results)
}

all.ma.dd.forecast <- sapply(1:n.sample, function(i) return(ma.dd.forecast(all.issues[,i])))

kable(mean.all.accuracy(all.ma.dd.forecast))
plot.all.pred(all.ma.dd.forecast)
plot.all.residuals(all.ma.dd.forecast)
hist.all.residuals(all.ma.dd.forecast)
```

# Regression

## Linear additive regression

```{r}
regr.add.forecast <- function(sample) {
  results = list()
  results$valid <- sample$valid.ts
  results$model <- tslm(sample$train.ts ~ season)
  results$pred <- forecast(results$model, h=n.valid)
  results$residual <- sample$valid.ts - results$pred$mean
  results$summary <- accuracy(results$pred, sample$valid.ts)
  
  return(results)
}

all.regr.add.forecast <- sapply(1:n.sample, function(i) return(regr.add.forecast(all.issues[,i])))

kable(mean.all.accuracy(all.regr.add.forecast))
plot.all.pred(all.regr.add.forecast)
plot.all.residuals(all.regr.add.forecast)
hist.all.residuals(all.regr.add.forecast)
```

## linear multiplicative regression

```{r}
regr.mult.forecast <- function(sample) {
  results = list()
  results$valid <- sample$valid.ts
  results$model <- tslm(sample$train.ts ~ season + trend, lambda = 1)
  results$pred <- forecast(results$model, h=n.valid)
  results$residual <- sample$valid.ts - results$pred$mean
  results$summary <- accuracy(results$pred, sample$valid.ts)
  
  return(results)
}

all.regr.mult.forecast <- sapply(1:n.sample, function(i) return(regr.mult.forecast(all.issues[,i])))

kable(mean.all.accuracy(all.regr.mult.forecast))
plot.all.pred(all.regr.mult.forecast)
plot.all.residuals(all.regr.mult.forecast)
hist.all.residuals(all.regr.mult.forecast)

```

## Arima

```{r}
arima.forecast <- function(sample) {
  results = list()
  results$valid <- sample$valid.ts
  results$model <- Arima(sample$train.ts, order=c(1,0,0), seasonal=c(1,1,1))
  results$pred <- forecast(results$model, h=n.valid)
  results$residual <- sample$valid.ts - results$pred$mean
  results$summary <- accuracy(results$pred, sample$valid.ts)
  
  return(results)
}

all.arima.forecast <- sapply(1:n.sample, function(i) return(arima.forecast(all.issues[,i])))

kable(mean.all.accuracy(all.arima.forecast))
plot.all.pred(all.arima.forecast)
plot.all.residuals(all.arima.forecast)
hist.all.residuals(all.arima.forecast)
```




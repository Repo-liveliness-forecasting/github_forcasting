nnetar.forecast <- function(sample) {
results <- list()
results$train <- sample$train.ts
results$valid <- sample$valid.ts
results$model <- nnetar(sample$train.ts)
results$pred <- forecast(results$model, h = n.valid)
results$fitted <- results$pred$fitted
results$residual <- sample$valid.ts - results$pred$mean
results$summary <- accuracy(results$pred, sample$valid.ts)
return(results)
}
all.nnetar.forecast <- sapply(1:n.sample, function(i) return(nnetar.forecast(all.issues[,i])))
a = 'Hello'
print a
print (a)
print (a + 'World')
cat (a + 'world')
cat (a, 'world')
kable(mean.all.accuracy(all.nnetar.forecast))
plot.all.pred(all.nnetar.forecast, 'Apache Spark (Neural Networks)')
plot.all.residuals(all.nnetar.forecast, 'Apache Spark (Neural Networks): Residuals')
hist.all.residuals(all.nnetar.forecast, 'Apache Spark (Neural Networks): Residuals')
boxplot.all.residuals(all.nnetar.forecast, 'Apache Spark (Neural Networks): Residuals')
ensemble.forecast <- function(list.of.forecast) {
results <- list()
results$train <- list.of.forecast[[1]]$train
results$valid <- list.of.forecast[[1]]$valid
valid.time <- time(results$valid)
train.time <- time(results$train)
mean.pred <- ts(
rowMeans(sapply(list.of.forecast, function(forecast) forecast$pred$mean)),
start = start(valid.time),
end = end(valid.time),
frequency = frequency(valid.time))
mean.fitted <- ts(
rowMeans(sapply(list.of.forecast, function(forecast) window(forecast$fitted, start = c(5,3)))),
start = start(train.time),
end = end(train.time),
frequency = frequency(train.time))
results$pred <- forecast.manual(window(results$train, start=c(5,3)), mean.fitted, mean.pred)
results$fitted <- results$pred$fitted
results$residual <- results$valid - results$pred$mean
results$summary <- accuracy(results$pred, results$valid)
return(results)
}
all.ensemble.forecast <- sapply(
1:n.sample,
function(i) return(ensemble.forecast(list(all.regr.mult.forecast[,i], all.hw.forecast[,i])))
)
kable(mean.all.accuracy(all.ensemble.forecast))
plot.all.pred(all.ensemble.forecast, 'Apache Spark (Ensemble)')
plot.all.residuals(all.ensemble.forecast, 'Apache Spark (Ensemble): Residuals')
hist.all.residuals(all.ensemble.forecast, 'Apache Spark (Ensemble): Residuals')
boxplot.all.residuals(all.ensemble.forecast, 'Apache Spark (Ensemble): Residuals')
title <- 'Apache Spark'
plot.all.pred(all.naive.forecast, (title + ' (Naive Forecast)'))
plot.all.pred(all.naive.forecast, cat(title, ' (Naive Forecast)'))
plot.all.pred(all.naive.forecast, paste(title, ' (Naive Forecast)'))
plot.all.pred(all.snaive.forecast, paste(title, ' (Seasonal Naive Forecast)'))
plot.all.residuals(all.snaive.forecast,
paste(title, ' (Seasonal Naive Forecast Residuals)'))
plot.all.pred(all.hw.forecast, paste(title, ' (Exponential Smoothing)'))
plot(issues.csv)
plot(issues.ts)
plot(issues.ts, main = 'Apache Spark', bty = 'l', ylab = 'Number of Issues',
xlab = 'Week', xlim = c(0, 54))
issues.csv <- read.csv('issues/apple_swift_daily.csv')
issues.csv <- issues.csv[1:(nrow(issues.csv) - 1), ]
issues.csv$date <- as.POSIXlt(as.Date(issues.csv$date, format='%Y-%m-%d'))
issues.csv <- subset(issues.csv, date <= to_date & date >= from_date)
issues.ts <- ts(issues.csv$number_of_issues, frequency = 7)
title <- 'Apple Swift'
plot(issues.ts, main = title, bty = 'l', ylab = 'Number of Issues',
xlab = 'Week', xlim = c(0, 54))
issues.csv <- read.csv('issues/julialang_julia_daily.csv')
issues.csv <- issues.csv[1:(nrow(issues.csv) - 1), ]
issues.csv$date <- as.POSIXlt(as.Date(issues.csv$date, format='%Y-%m-%d'))
issues.csv <- subset(issues.csv, date <= to_date & date >= from_date)
issues.ts <- ts(issues.csv$number_of_issues, frequency = 7)
title <- 'Julialang Julia'
plot(issues.ts, main = title, bty = 'l', ylab = 'Number of Issues',
xlab = 'Week', xlim = c(0, 54))
issues.csv <- read.csv('issues/nodejs_node_daily.csv')
issues.csv <- issues.csv[1:(nrow(issues.csv) - 1), ]
issues.csv$date <- as.POSIXlt(as.Date(issues.csv$date, format='%Y-%m-%d'))
issues.csv <- subset(issues.csv, date <= to_date & date >= from_date)
issues.ts <- ts(issues.csv$number_of_issues, frequency = 7)
title <- 'Nodejs Node'
plot(issues.ts, main = title, bty = 'l', ylab = 'Number of Issues',
xlab = 'Week', xlim = c(0, 54))
issues.csv <- read.csv('issues/tensorflow_tensorflow_daily.csv')
issues.csv <- issues.csv[1:(nrow(issues.csv) - 1), ]
issues.csv$date <- as.POSIXlt(as.Date(issues.csv$date, format='%Y-%m-%d'))
issues.csv <- subset(issues.csv, date <= to_date & date >= from_date)
issues.ts <- ts(issues.csv$number_of_issues, frequency = 7)
title <- 'Tensorflow'
plot(issues.ts, main = title, bty = 'l', ylab = 'Number of Issues',
xlab = 'Week', xlim = c(0, 54))
issues.csv <- read.csv('issues/nodejs_node_daily.csv')
issues.csv <- issues.csv[1:(nrow(issues.csv) - 1), ]
issues.csv$date <- as.POSIXlt(as.Date(issues.csv$date, format='%Y-%m-%d'))
issues.csv <- subset(issues.csv, date <= to_date & date >= from_date)
issues.ts <- ts(issues.csv$number_of_issues, frequency = 7)
issues.csv <- read.csv('issues/nodejs_node_daily.csv')
issues.csv <- issues.csv[1:(nrow(issues.csv) - 1), ]
issues.csv$date <- as.POSIXlt(as.Date(issues.csv$date, format='%Y-%m-%d'))
issues.csv <- subset(issues.csv, date <= to_date & date >= from_date)
issues.ts <- ts(issues.csv$number_of_issues, frequency = 7)
issues.csv <- read.csv('issues/nodejs_node_daily.csv')
issues.csv <- issues.csv[1:(nrow(issues.csv) - 1), ]
issues.csv$date <- as.POSIXlt(as.Date(issues.csv$date, format='%Y-%m-%d'))
issues.csv <- subset(issues.csv, date <= to_date & date >= from_date)
issues.csv$date[issues.csv$number_of_issues == 220]
issues.csv[issues.csv$number_of_issues == 220]
issues.csv$number_of_issues[issues.csv$date == '2016-12-01'] = 16
issues.ts <- ts(issues.csv$number_of_issues, frequency = 7)
title <- 'Nodejs Node'
plot(issues.ts, main = title, bty = 'l', ylab = 'Number of Issues',
xlab = 'Week', xlim = c(0, 54))
issues.ts[40:50]
issues.ts[30:50]
issues.ts[20:50]
tail(issues.ts, 20)
tail(issues.ts, 30)
issues.ts[number_of_issues == 220]
issues.ts[issues.ts$number_of_issues == 220]
issues.ts
issues.ts[339]
issues.ts[339] = 16
plot(issues.ts, main = title, bty = 'l', ylab = 'Number of Issues',
xlab = 'Week', xlim = c(0, 54))
issues.ts[339]
issues.ts[264]
mean(3, 5)
mean(3 + 5)
issues.ts[264] = (13 + 11) / 2
issues.ts[264]
plot(issues.ts, main = title, bty = 'l', ylab = 'Number of Issues',
plot(issues.ts, main = title, bty = 'l', ylab = 'Number of Issues',
xlab = 'Week', xlim = c(0, 54))
hw.forecast <- function(sample) {
results <- list()
results$train <- sample$train.ts
results$valid <- sample$valid.ts
results$model <- ets(sample$train.ts, model = "ZZZ", allow.multiplicative.trend = TRUE,
restrict = FALSE)
results$pred <- forecast(results$model, h = n.valid)
results$fitted <- results$pred$fitted
results$residual <- sample$valid.ts - results$pred$mean
results$summary <- accuracy(results$pred, sample$valid.ts)
return(results)
}
all.hw.forecast <- sapply(1:n.sample, function(i) return(hw.forecast(all.issues[,i])))
kable(mean.all.accuracy(all.hw.forecast))
separate.train.test <- function(timeseries, n.valid) {
time <- time(timeseries)
n.train <- length(timeseries) - n.valid
results <- list()
results$train.ts <- window(timeseries, start = time[1], end = time[n.train])
results$valid.ts <- window(timeseries, start = time[n.train + 1],
end = time[n.train + n.valid])
return(results)
}
all.issues <- sapply(0:(n.sample - 1), function(i) return(separate.train.test(window(
issues.ts, start = time[1], end = time[length(issues.ts) - i]), n.valid
)))
mean.all.accuracy <- function(all.forecast) {
Reduce('+', all.forecast['summary', ]) / length(all.forecast['summary', ])
}
plot.all.pred <- function(all.forecast, plot.title) {
plot(issues.ts, main = plot.title, bty = 'l', ylab = 'Number of Issues',
xlab = 'Week', xlim = c(30, 53.3))
if (class(all.forecast['pred', 1]$pred) == 'forecast') {
sapply(1:n.sample, function(i) lines(all.forecast['pred', i]$pred$mean, col = rgb(0, 0, 1, 0.5)))
} else {
sapply(1:n.sample, function(i) lines(all.forecast['pred', i]$pred, col = rgb(0, 0, 1, 0.5)))
}
return(NULL)
}
plot.all.residuals <- function(all.forecast, plot.title) {
plot(1, bty = 'l', main = plot.title, xlim = c(30, 53.3), ylim = c(-40, 40),
xlab = 'Week', ylab = 'Errors')
sapply(1:n.sample, function(i) lines(
all.forecast['train', i]$train - all.forecast['fitted', i]$fitted
))
sapply(1:n.sample, function(i) lines(all.forecast['residual',i]$residual, col = 'blue'))
return(NULL)
}
plot.pred <- function(forecast.with.interval.ts, plot.title) {
plot(issues.ts, main = plot.title, xlim = c(30, 53.3), xlab = 'Week',
ylab = 'Number of Issues')
apply(forecast.with.interval.ts, 2, function(x) lines(x))
return(NULL)
}
hist.all.residuals <- function(all.forecast, plot.title) {
residuals <- sapply(1:n.sample, function(i) as.numeric(
all.forecast['residual', i]$residual
))
hist(residuals, main = plot.title)
quantile(residuals, c(0.975, 0.95, 0.05, 0.025))
}
boxplot.all.residuals <- function(all.forecast, plot.title) {
residuals <- sapply(1:n.sample, function(i) as.numeric(
all.forecast['residual', i]$residual
))
boxplot(apply(residuals, 1, quantile.helper), main = plot.title)
return (quantile(residuals, c(0.975, 0.95, 0.05, 0.025)))
}
quantile.helper <- function(matrix) {
return (quantile(matrix, c(0.975, 0.95, 0.05, 0.025)))
}
get.quantile.of.residuals <- function(all.forecast) {
residuals <- sapply(1:n.sample, function(i) as.numeric(
all.forecast['residual', i]$residual
))
return (apply(residuals, 1, quantile.helper))
}
forecast.confidence <- function(ets.test.model.pred, quantile.of.residuals) {
forecast.confidence.interval <- apply(quantile.of.residuals, 1, function(a.quantile) return(a.quantile + ets.test.model.pred))
return(forecast.confidence.interval)
}
forecast.manual.interval <- function(x.train, f.train, f.pred, f.lower, f.upper) {
mean <- f.pred
x <- x.train
residuals <- x.train - f.train
fitted <- f.train
level <- c(80, 95)
lower <- f.lower
upper <- f.upper
output <- list(mean = mean, x = x, residuals = residuals, fitted = fitted, level = level, lower = lower, upper = upper)
return(structure(output, class = 'forecast'))
}
forecast.manual <- function(x.train, f.train, f.pred) {
mean <- f.pred
x <- x.train
residuals <- x.train - f.train
fitted <- f.train
output <- list(mean = mean, x = x, residuals = residuals, fitted = fitted)
return(structure(output, class = 'forecast'))
}
hw.forecast <- function(sample) {
results <- list()
results$train <- sample$train.ts
results$valid <- sample$valid.ts
results$model <- ets(sample$train.ts, model = "ZZZ", allow.multiplicative.trend = TRUE,
restrict = FALSE)
results$pred <- forecast(results$model, h = n.valid)
results$fitted <- results$pred$fitted
results$residual <- sample$valid.ts - results$pred$mean
results$summary <- accuracy(results$pred, sample$valid.ts)
return(results)
}
all.hw.forecast <- sapply(1:n.sample, function(i) return(hw.forecast(all.issues[,i])))
kable(mean.all.accuracy(all.hw.forecast))
regr.add.forecast <- function(sample) {
results <- list()
results$train <- sample$train.ts
results$valid <- sample$valid.ts
results$model <- tslm(sample$train.ts ~ season)
results$pred <- forecast(results$model, h=n.valid)
results$fitted <- results$pred$fitted
results$residual <- sample$valid.ts - results$pred$mean
results$summary <- accuracy(results$pred, sample$valid.ts)
return(results)
}
all.regr.add.forecast <- sapply(1:n.sample, function(i) return(
regr.add.forecast(all.issues[, i])))
kable(mean.all.accuracy(all.regr.add.forecast))
ensemble.forecast <- function(list.of.forecast) {
results <- list()
results$train <- list.of.forecast[[1]]$train
results$valid <- list.of.forecast[[1]]$valid
valid.time <- time(results$valid)
train.time <- time(results$train)
mean.pred <- ts(
rowMeans(sapply(list.of.forecast, function(forecast) forecast$pred$mean)),
start = start(valid.time),
end = end(valid.time),
frequency = frequency(valid.time))
mean.fitted <- ts(
rowMeans(sapply(list.of.forecast, function(forecast) window(forecast$fitted, start = c(5,3)))),
start = start(train.time),
end = end(train.time),
frequency = frequency(train.time))
results$pred <- forecast.manual(window(results$train, start=c(5,3)), mean.fitted, mean.pred)
results$fitted <- results$pred$fitted
results$residual <- results$valid - results$pred$mean
results$summary <- accuracy(results$pred, results$valid)
return(results)
}
all.ensemble.forecast <- sapply(
1:n.sample,
function(i) return(ensemble.forecast(list(all.regr.add.forecast[,i], all.hw.forecast[,i])))
)
kable(mean.all.accuracy(all.ensemble.forecast))
get.quantile.of.residuals(all.ensemble.forecast)
quantile.of.residuals = get.quantile.of.residuals(all.ensemble.forecast)
forecast.confidence(all.ensemble.forecast, quantile.of.residuals)
issues.csv <- read.csv('issues/apache_spark_daily.csv')
issues.csv <- issues.csv[1:(nrow(issues.csv) - 1), ]
issues.csv <- read.csv('issues/apache_spark_daily.csv')
issues.csv <- issues.csv[1:(nrow(issues.csv) - 1), ]
issues.csv$date <- as.POSIXlt(as.Date(issues.csv$date, format='%Y-%m-%d'))
to_date <- issues.csv$date[length(issues.csv$date)]
from_date <- to_date
from_date$year <- from_date$year - 1
issues.csv <- subset(issues.csv, date <= to_date & date >= from_date)
issues.ts <- ts(issues.csv$number_of_issues, frequency = 7)
time <- time(issues.ts)
n.valid <- 21
title <- 'Apache Spark'
n.sample <- 28
separate.train.test <- function(timeseries, n.valid) {
time <- time(timeseries)
n.train <- length(timeseries) - n.valid
results <- list()
results$train.ts <- window(timeseries, start = time[1], end = time[n.train])
results$valid.ts <- window(timeseries, start = time[n.train + 1],
end = time[n.train + n.valid])
return(results)
}
all.issues <- sapply(0:(n.sample - 1), function(i) return(separate.train.test(window(
issues.ts, start = time[1], end = time[length(issues.ts) - i]), n.valid
)))
mean.all.accuracy <- function(all.forecast) {
Reduce('+', all.forecast['summary', ]) / length(all.forecast['summary', ])
}
plot.all.pred <- function(all.forecast, plot.title) {
plot(issues.ts, main = plot.title, bty = 'l', ylab = 'Number of Issues',
xlab = 'Week', xlim = c(30, 53.3))
if (class(all.forecast['pred', 1]$pred) == 'forecast') {
sapply(1:n.sample, function(i) lines(all.forecast['pred', i]$pred$mean, col = rgb(0, 0, 1, 0.5)))
} else {
sapply(1:n.sample, function(i) lines(all.forecast['pred', i]$pred, col = rgb(0, 0, 1, 0.5)))
}
return(NULL)
}
plot.all.residuals <- function(all.forecast, plot.title) {
plot(1, bty = 'l', main = plot.title, xlim = c(30, 53.3), ylim = c(-40, 40),
xlab = 'Week', ylab = 'Errors')
sapply(1:n.sample, function(i) lines(
all.forecast['train', i]$train - all.forecast['fitted', i]$fitted
))
sapply(1:n.sample, function(i) lines(all.forecast['residual',i]$residual, col = 'blue'))
return(NULL)
}
plot.pred <- function(forecast.with.interval.ts, plot.title) {
plot(issues.ts, main = plot.title, xlim = c(30, 53.3), xlab = 'Week',
ylab = 'Number of Issues')
apply(forecast.with.interval.ts, 2, function(x) lines(x))
return(NULL)
}
hist.all.residuals <- function(all.forecast, plot.title) {
residuals <- sapply(1:n.sample, function(i) as.numeric(
all.forecast['residual', i]$residual
))
hist(residuals, main = plot.title)
quantile(residuals, c(0.975, 0.95, 0.05, 0.025))
}
boxplot.all.residuals <- function(all.forecast, plot.title) {
residuals <- sapply(1:n.sample, function(i) as.numeric(
all.forecast['residual', i]$residual
))
boxplot(apply(residuals, 1, quantile.helper), main = plot.title)
return (quantile(residuals, c(0.975, 0.95, 0.05, 0.025)))
}
quantile.helper <- function(matrix) {
return (quantile(matrix, c(0.975, 0.95, 0.05, 0.025)))
}
get.quantile.of.residuals <- function(all.forecast) {
residuals <- sapply(1:n.sample, function(i) as.numeric(
all.forecast['residual', i]$residual
))
return (apply(residuals, 1, quantile.helper))
}
forecast.confidence <- function(ets.test.model.pred, quantile.of.residuals) {
forecast.confidence.interval <- apply(quantile.of.residuals, 1, function(a.quantile) return(a.quantile + ets.test.model.pred))
return(forecast.confidence.interval)
}
forecast.manual.interval <- function(x.train, f.train, f.pred, f.lower, f.upper) {
mean <- f.pred
x <- x.train
residuals <- x.train - f.train
fitted <- f.train
level <- c(80, 95)
lower <- f.lower
upper <- f.upper
output <- list(mean = mean, x = x, residuals = residuals, fitted = fitted, level = level, lower = lower, upper = upper)
return(structure(output, class = 'forecast'))
}
forecast.manual <- function(x.train, f.train, f.pred) {
mean <- f.pred
x <- x.train
residuals <- x.train - f.train
fitted <- f.train
output <- list(mean = mean, x = x, residuals = residuals, fitted = fitted)
return(structure(output, class = 'forecast'))
}
hw.forecast <- function(sample) {
results <- list()
results$train <- sample$train.ts
results$valid <- sample$valid.ts
results$model <- ets(sample$train.ts, model = "ZZZ", allow.multiplicative.trend = TRUE,
restrict = FALSE)
results$pred <- forecast(results$model, h = n.valid)
results$fitted <- results$pred$fitted
results$residual <- sample$valid.ts - results$pred$mean
results$summary <- accuracy(results$pred, sample$valid.ts)
return(results)
}
all.hw.forecast <- sapply(1:n.sample, function(i) return(hw.forecast(all.issues[,i])))
regr.mult.forecast <- function(sample) {
train.ts <- sample$train.ts
valid.ts <- sample$valid.ts
train.lm <- tslm(train.ts ~ season, lambda = 0)
train.lm.pred <- forecast(train.lm, h=n.valid)
lm.summary <- accuracy(train.lm.pred, valid.ts)
results <- list()
results$train <- train.ts
results$valid <- valid.ts
results$model <- train.lm
results$pred <- train.lm.pred
results$fitted <- train.lm.pred$fitted
results$residual <- valid.ts - train.lm.pred$mean
results$summary <- lm.summary
return(results)
}
all.regr.mult.forecast <- sapply(1:n.sample, function(i) return(
regr.mult.forecast(all.issues[, i])))
kable(mean.all.accuracy(all.hw.forecast))
kable(mean.all.accuracy(all.regr.mult.forecast))
ensemble.forecast <- function(list.of.forecast) {
results <- list()
results$train <- list.of.forecast[[1]]$train
results$valid <- list.of.forecast[[1]]$valid
valid.time <- time(results$valid)
train.time <- time(results$train)
mean.pred <- ts(
rowMeans(sapply(list.of.forecast, function(forecast) forecast$pred$mean)),
start = start(valid.time),
end = end(valid.time),
frequency = frequency(valid.time))
mean.fitted <- ts(
rowMeans(sapply(list.of.forecast, function(forecast) window(forecast$fitted, start = c(5,3)))),
start = start(train.time),
end = end(train.time),
frequency = frequency(train.time))
results$pred <- forecast.manual(window(results$train, start=c(5,3)), mean.fitted, mean.pred)
results$fitted <- results$pred$fitted
results$residual <- results$valid - results$pred$mean
results$summary <- accuracy(results$pred, results$valid)
return(results)
}
all.ensemble.forecast <- sapply(
1:n.sample,
function(i) return(ensemble.forecast(list(all.regr.mult.forecast[,i], all.hw.forecast[,i])))
)
kable(mean.all.accuracy(all.ensemble.forecast))
plot.all.pred(all.ensemble.forecast, paste(title, ' (Ensemble)'))
plot.all.residuals(all.ensemble.forecast, paste(title, ' (Ensemble): Residuals'))
plot.all.residuals <- function(all.forecast, plot.title) {
plot(1, bty = 'l', main = plot.title, xlim = c(30, 53.3), ylim = c(-40, 40),
xlab = 'Week', ylab = 'Errors')
legends(30, 40, c('Train', 'Valid'), lwd = c(1, 1), lty = c(1, 1), col = c('black', 'blue'), bty = 'n')
sapply(1:n.sample, function(i) lines(
all.forecast['train', i]$train - all.forecast['fitted', i]$fitted
))
sapply(1:n.sample, function(i) lines(all.forecast['residual',i]$residual, col = 'blue'))
return(NULL)
}
plot.all.residuals(all.ensemble.forecast, paste(title, ' (Ensemble): Residuals'))
plot.all.residuals <- function(all.forecast, plot.title) {
plot(1, bty = 'l', main = plot.title, xlim = c(30, 53.3), ylim = c(-40, 40),
xlab = 'Week', ylab = 'Errors')
legend(30, 40, c('Train', 'Valid'), lwd = c(1, 1), lty = c(1, 1), col = c('black', 'blue'), bty = 'n')
sapply(1:n.sample, function(i) lines(
all.forecast['train', i]$train - all.forecast['fitted', i]$fitted
))
sapply(1:n.sample, function(i) lines(all.forecast['residual',i]$residual, col = 'blue'))
return(NULL)
}
plot.all.residuals(all.ensemble.forecast, paste(title, ' (Ensemble): Residuals'))
plot.all.residuals <- function(all.forecast, plot.title) {
plot(1, bty = 'l', main = plot.title, xlim = c(30, 53.3), ylim = c(-40, 40),
xlab = 'Week', ylab = 'Errors')
legend(30, 50, c('Train', 'Valid'), lwd = c(1, 1), lty = c(1, 1), col = c('black', 'blue'), bty = 'n')
sapply(1:n.sample, function(i) lines(
all.forecast['train', i]$train - all.forecast['fitted', i]$fitted
))
sapply(1:n.sample, function(i) lines(all.forecast['residual',i]$residual, col = 'blue'))
return(NULL)
}
plot.all.residuals(all.ensemble.forecast, paste(title, ' (Ensemble): Residuals'))
plot.all.residuals <- function(all.forecast, plot.title) {
plot(1, bty = 'l', main = plot.title, xlim = c(30, 53.3), ylim = c(-40, 40),
xlab = 'Week', ylab = 'Errors')
legend(30, 50, c('Train', 'Valid'), lwd = c(1, 2), lty = c(1, 1), col = c('black', 'blue'), bty = 'n')
sapply(1:n.sample, function(i) lines(
all.forecast['train', i]$train - all.forecast['fitted', i]$fitted
))
sapply(1:n.sample, function(i) lines(all.forecast['residual',i]$residual, col = 'blue'))
return(NULL)
}
plot.all.residuals(all.ensemble.forecast, paste(title, ' (Ensemble): Residuals'))
Acf(all.ensemble.forecast['residual', ]$residual, lag.max = 7, main = 'Apache Spark: Acf on lag-1 difference')
all.ensemble.forecast['residual', ]
all.ensemble.forecast['residual', ]$residual
Acf(all.ensemble.forecast['residual', ], lag.max = 7, main = 'Apache Spark: Acf on Ensemble Residuals')
```
Acf(all.ensemble.forecast['residual', ], lag.max = 7, main = 'Apache Spark: Acf on Ensemble Residuals')
Acf(all.ensemble.forecast['residual', 1], lag.max = 7, main = 'Apache Spark: Acf on Ensemble Residuals')
boxplot.all.residuals(all.ensemble.forecast, paste(title, ' (Ensemble): Residuals'))
